#!/usr/bin/python

# See file COPYING distributed with the this code for the copyright
# and license.

import sys
import os
import traceback
import errno
import argparse
import subprocess
import re
import tempfile
import shutil
import zipfile
import json
import dicom
import boto.s3.connection
import nibabel

description = """

ndar_unpack checks, describes, and unpacks imaging data from NDAR.

There are three main functions:

    Check: report whether the packaged data is sensible.  Is it just a header 
           without volume data?  Is it not volume data at all?  Every 
           ndar_unpack run first checks the data.

    Describe: derive as much of the image03 structure as possible from the 
              data itself.

    Unpack: create a volume of a given format or a thumbnail image from the 
            data.

There are a number of outcomes from an ndar_unpack run.  Outcomes and their 
exit values are:

    Data is okay, and a successful ndar_unpack run.  Returns 0.

    Error in running ndar_unpack.  This is when ndar_unpack could not run 
    to completion for some reason, with the exception of the following 
    cases.  Returns 1.

    Command line error.  Mind your -ps and -qs.  Returns 2.

    Bad data.  The data is bad.  Maybe it's empty; maybe it's in an 
    unsupported format.  Returns 3.

    Undetermined outcome: ndar_unpack failed to run as expected, but not 
    in a way that indicates permanent failure.  This is the case if a 
    helper program doesn't exist or if the data looks okay, but 
    ndar_unpack hasn't been developed to the point of supporting it.  
    Returns 4.

Written by Christian Haselgrove, 2014.

"""

image03_fields = ('subjectkey', 'src_subject_id', 'interview_date', 
                  'interview_age', 'gender', 'comments_misc', 'image_file', 
                  'image_thumbnail_file', 'image_description', 
                  'image_file_format', 'image_modality', 
                  'scanner_manufacturer_pd', 'scanner_type_pd', 
                  'scanner_software_versions_pd', 'magnetic_field_strength', 
                  'mri_repetition_time_pd', 'mri_echo_time_pd', 'flip_angle', 
                  'acquisition_matrix', 'mri_field_of_view_pd', 
                  'patient_position', 'photomet_interpret', 'receive_coil', 
                  'transmit_coil', 'transformation_performed', 
                  'transformation_type', 'image_history', 
                  'image_num_dimensions', 'image_extent1', 'image_extent2', 
                  'image_extent3', 'image_extent4', 'extent4_type', 
                  'image_extent5', 'extent5_type', 'image_unit1', 
                  'image_unit2', 'image_unit3', 'image_unit4', 'image_unit5', 
                  'image_resolution1', 'image_resolution2', 
                  'image_resolution3', 'image_resolution4', 
                  'image_resolution5', 'image_slice_thickness', 
                  'image_orientation', 'qc_outcome', 'qc_description', 
                  'qc_fail_quest_reason', 'time_diff_units', 
                  'decay_correction', 'frame_end_times', 'frame_end_unit', 
                  'frame_start_times', 'frame_start_unit', 'pet_isotope', 
                  'pet_tracer', 'time_diff_inject_to_image', 'pulse_seq', 
                  'slice_acquisition', 'software_preproc', 'experiment_id', 
                  'scan_type', 'data_file2', 'data_file2_type')

def convert_dicom_time(val):
    return str(float(val)/1000.0)

def convert_dicom_date(val):
    mo = dicom_date_re.search(val)
    if mo is None:
        return None
    return '%s/%s/%s' % (mo.groupdict['month'], 
                         mo.groupdict['day'], 
                         mo.groupdict['year'])

def convert_dicom_float(val):
    if not isinstance(val, dicom.valuerep.DSfloat):
        return None
    return float(val)

dicom_date_re = re.compile('^(P<year>\d\d\d\d)(P<month>\d\d)(P<day>\d\d)$')

# image03 field => (DICOM tag, formatting/conversion function)
image03_dicom = {'gender': ('PatientSex', None), 
                 'image_modality': ('Modality', None), 
                 'scanner_manufacturer_pd': ('Manufacturer', None), 
                 'scanner_type_pd': ('ManufacturerModelName', None), 
                 'magnetic_field_strength': ('MagneticFieldStrength', 
                                             convert_dicom_float),  
                 'flip_angle': ('FlipAngle', convert_dicom_float), 
                 'acquisition_matrix': ('AcquisitionMatrix', None), 
                 'patient_position': ('PatientPosition', None), 
                 'photomet_interpret': ('PhotometricInterpretation', None), 
                 'receive_coil': ('ReceiveCoilName', None), 
                 'transmit_coil': ('TransmitCoilName', None), 
                 'interview_date': ('StudyDate', convert_dicom_date), 
                 'mri_repetition_time_pd': ('RepititionTime', 
                                            convert_dicom_time),
                 'mri_echo_time_pd': ('EchoTime', convert_dicom_time)}

SILENT = 0
ERROR = 1
NOTICE = 2
DEBUG = 3

#############################################################################
# exceptions
#

class BaseError(Exception):

    """base class for exceptions"""

    def __init__(self, error):
        self.error = error

    def __str__(self):
        return self.error

class DataError(BaseError):

    """error in the data"""

    def __str__(self):
        return 'bad data: %s' % self.error

class UndeterminedError(BaseError):

    """undetermined error"""

    def __str__(self):
        return 'undetermined error: %s' % self.error

class GeneralError(BaseError):

    """error running"""

#############################################################################
# classes
#

class BaseData:

    """base class for data handling classes

    Subclasses should define:

        @property image03(), which returns a dictionary containing the 
        image03 structure

        nii_gz(), which creates a .nii.gz.  If a file name is specified, 
        the NIfTI volume should be written to that file; otherwise a 
        temporary file should be created.  Returns the file name.

    Each subclass should define __init__() such that it returns only if 
    it is prepared to handle the data in the passed temporary directory.  
    If the class rejects the data (e.g. a DICOM handler recieves a NIfTI 
    file), __init__() should raise TypeError; if the class accepts the 
    data but finds an error (e.g. a DICOM handler finds more than one 
    series), __init__() should raise DataError.
    """

    def __init__(self, tempdir):
        self.tempdir = tempdir
        self.contents = []
        self.unpacked_dir = os.path.join(self.tempdir, 'unpacked')
        for (dir, dirs, files) in os.walk(self.unpacked_dir):
            for f in files:
                self.contents.append(os.path.join(dir, f))
        # a serial number for process output
        self.process_index = 0
        self._image03 = None
        return

    def _image03_from_nifti(self):
        """fill as much of the image03 structure as possible from the NIfTI 
        volume

        this also initializes _image03 with the known fields
        """
        self._image03 = {}
        for field in image03_fields:
            self._image03[field] = None
        vol = nibabel.load(self.nii_gz())
        try:
            (xyz_units, t_units) = vol.get_header().get_xyzt_units()
        except:
            (xyz_units, t_units) = (None, None)
        if xyz_units == 'mm':
            xyz_units = 'Millimeters'
        elif xyz_units == 'm':
            xyz_units = 'Meters'
        elif xyz_units == 'um':
            xyz_units = 'Micrometers'
        else:
            xyz_units = None
        if t_units == 's':
            t_units = 'Seconds'
        elif t_units == 'ms':
            t_unit = 'Milliseconds'
        elif t_units == 'ms':
            t_unit = 'Microseconds'
        else:
            t_unit = None
        self.image_num_dimensions = len(vol.shape)
        pixdim = vol.get_header()['pixdim']
        for i in xrange(self.image_num_dimensions):
            self._image03['image_extent%d' % (i+1)] = vol.shape[i]
            self._image03['image_resolution%d' % (i+1)] = float(pixdim[i+1])
            if i < 3 and xyz_units:
                self._image03['image_unit%d' % (i+1)] = xyz_units
            if i == 3 and t_units:
                self._image03['image_unit4'] = t_unit
        return self._image03

    def call(self, args):
        message(DEBUG, 'running (%d) %s' % (self.process_index, ' '.join(args)))
        stdout_f = None
        stderr_f = None
        stdout_fname = os.path.join(os.path.join(self.tempdir, 'output'), 
                                    '%d.out' % self.process_index)
        stderr_fname = os.path.join(os.path.join(self.tempdir, 'output'), 
                                    '%d.err' % self.process_index)
        try:
            stdout_f = open(stdout_fname, 'w')
            stderr_f = open(stderr_fname, 'w')
            self.process_index += 1
            rv = subprocess.call(args, stdout=stdout_f, stderr=stderr_f)
        except OSError, exc:
            # ENOENT if the program couldn't be found
            if exc.errno == errno.ENOENT:
                msg = 'couldn\'t find %s' % args[0]
            else:
                msg = str(exc)
            raise UndeterminedError(msg)
        finally:
            if stdout_f:
                stdout_f.close()
            if stderr_f:
                stderr_f.close()
        if rv < 0:
            raise UndeterminedError('%s killed by signal %d' % (args[0], -rv))
        if args[0] == 'mri_convert':
            stderr = open(stderr_fname).read()
            if 'ERROR: FreeSurfer license file' in stderr:
                raise UndeterminedError('FreeSurfer license not found')
        return rv

    def check_call(self, args):
        rv = self.call(args)
        if rv:
            raise GeneralError('error running %s' % args[0])
        return

class NIfTIGzData(BaseData):

    def __init__(self, tempdir):
        BaseData.__init__(self, tempdir)
        if not self.contents:
            raise TypeError('no files')
        if len(self.contents) != 1:
            raise TypeError('too many files')
        if not self.contents[0].endswith('.nii.gz'):
            raise TypeError('bad extension')
        rv = self.call(['mri_convert', '-ro', self.contents[0]])
        if rv:
            raise DataError('could not read .nii.gz')
        return

    @property
    def image03(self):
        if self._image03:
            return self._image03
        self._image03_from_nifti()
        self._image03['image_file_format'] = 'NIfTI'
        return self._image03

    def nii_gz(self, path=None):
        if not path:
            return self.contents[0]
        shutil.copy(self.contents[0], path)
        return path

class DICOMData(BaseData):

    def __init__(self, tempdir):
        BaseData.__init__(self, tempdir)
        if not self.contents:
            raise TypeError('no files')
        series_uids = []
        for f in self.contents:
            try:
                do = dicom.read_file(f)
            except:
                raise TypeError('non-DICOM found')
            try:
                uid = str(do.SeriesInstanceUID)
            except AttributeError:
                raise DataErro('DICOM file without Series Instance UID')
            if not uid:
                raise DataError('DICOM file with empty Series Instance UID')
            if uid not in series_uids:
                series_uids.append(uid)
        if len(series_uids) > 1:
            raise DataError('multiple series found')
        return

    @property
    def image03(self):
        if self._image03:
            return self._image03
        self._image03_from_nifti()
        do = dicom.read_file(self.contents[0])
        for (field, (tag, converter)) in image03_dicom.iteritems():
            try:
                value = getattr(do, tag)
                if not value:
                    value = None
                elif converter is not None:
                    value = converter(value)
                self._image03[field] = value
            except AttributeError:
                pass
        self._image03['image_file_format'] = 'DICOM'
        return self._image03

    def nii_gz(self, path=None):
        if not path:
            path = os.path.join(self.tempdir, 'volume.nii.gz')
        self.check_call(['mri_convert', self.contents[0], path])
        return path

#############################################################################
# functions
#

def message(level, msg):
    fo = sys.stdout
    if level > output_level:
        return
    if level == DEBUG:
        prefix = 'DEBUG: '
    elif level == ERROR:
        fo = sys.stderr
        prefix = '%s: ' % progname
    else:
        prefix = ''
    for line in msg.split('\n'):
        fo.write('%s%s\n' % (prefix, line))
    return

#############################################################################
# command line parsing
#

progname = os.path.basename(sys.argv[0])

parser = argparse.ArgumentParser(description=description, 
                                 formatter_class=argparse.RawTextHelpFormatter)

parser.add_argument('--volume', '-v', 
                    metavar='<output volume>', 
action='append', 
                    help='An output volume.')
parser.add_argument('--thumbnail', '-t')
parser.add_argument('--image03', '-i')
parser.add_argument('--format', '-f', 
                    default='text', 
                    help='image03 output format', 
                    choices=('text', 'json'))
parser.add_argument('--aws-access-key-id')
parser.add_argument('--aws-secret-access-key')
parser.add_argument('--debug', '-d', 
                    default=False, 
                    dest='debug_flag', 
                    action='store_true', 
                    help='debug flag; overrides -q')
parser.add_argument('--dont-clean', '-D', 
                    default=True, 
                    dest='clean_flag', 
                    action='store_false', 
                    help='don\'t remove the temporary directory on exit')
parser.add_argument('--quiet', '-q', 
                    default=0, 
                    action='count', 
                    help='quiet flag; set twice for no output')
parser.add_argument('input', 
                    help='the input file or S3 URL')

args = parser.parse_args()

#############################################################################
# command line/input checks
#

output_level = NOTICE
if args.debug_flag:
    output_level = DEBUG
elif args.quiet:
    if args.quiet == 1:
        output_level = ERROR
    else:
        output_level = SILENT

errors = []

if args.volume:
    for fname in args.volume:
        if os.path.exists(fname):
            errors.append('%s exists' % fname)
        else:
            if not fname.endswith('.nii.gz'):
                errors.append('unknown extension for volume %s' % fname)

if args.thumbnail and os.path.exists(args.thumbnail):
    errors.append('%s exists' % args.thumbnail)

if args.image03 and args.image03 != '-' and os.path.exists(args.image03):
    errors.append('%s exists' % args.image03)

if args.input.startswith('s3://'):
    if not args.aws_access_key_id:
        errors.append('input is from S3 but no AWS access key ID given')
    if not args.aws_secret_access_key:
        errors.append('input is from S3 but no AWS secret access key given')

if errors:
    for e in errors:
        message(ERROR, e)
    sys.exit(1)

#############################################################################
# begin execution
#

try:

    tempdir = tempfile.mkdtemp()
    source_dir = os.path.join(tempdir, 'source')
    unpacked_dir = os.path.join(tempdir, 'unpacked')
    output_dir = os.path.join(tempdir, 'output')
    os.mkdir(source_dir)
    os.mkdir(unpacked_dir)
    os.mkdir(output_dir)

    source_basename = os.path.basename(args.input)
    temp_source = os.path.join(source_dir, source_basename)

    if args.input.startswith('s3://'):
        try:
            message(NOTICE, 'downloading data...')
            parts = args.input[5:].split('/', 1)
            # s3://bucket or s3://bucket/
            if len(parts) == 1 or not parts[1]:
                raise GeneralError('incomplete S3 URL')
            (bucket, path) = parts
            cf = boto.s3.connection.OrdinaryCallingFormat()
            conn = boto.connect_s3(args.aws_access_key_id, 
                                   args.aws_secret_access_key, 
                                   calling_format=cf)
            message(DEBUG, 'getting S3 bucket %s' % bucket)
            b = conn.get_bucket(bucket)
            message(DEBUG, 'looking for S3 object %s' % path)
            k = b.get_key(path)
            if not k:
                raise GeneralError('%s not found' % url)
            message(DEBUG, 'downloading S3 object to %s' % temp_source)
            k.get_contents_to_filename(temp_source)
            k.close()
            conn.close()
        except boto.exception.S3ResponseError, exc:
            self.clean()
            raise GeneralError('S3 error: %s' % exc.message)
    else:
        message(DEBUG, 'linking source to %s' % temp_source)
        os.symlink(os.path.abspath(args.input), temp_source)

    if args.input.endswith('.zip'):
        message(NOTICE, 'unpacking ZIP file...')
        try:
            zf = zipfile.ZipFile(temp_source)
            zf.extractall(unpacked_dir)
            zf.close()
        except zipfile.BadZipfile:
            raise DataError('error in zip file')
    else:
        message(DEBUG, 'linking source to unpacked/')
        os.symlink(temp_source, os.path.join(unpacked_dir, source_basename))

    # attempt to find a handler for the data
    # each class constructor will raise TypeError if it won't handle the data 
    # and DataError if it finds an error in the data, so hidden in this loop 
    # is also data checking
    message(NOTICE, 'inspecting data...')
    data = None
    for data_class in (NIfTIGzData, DICOMData):
        try:
            message(DEBUG, 'trying %s' % str(data_class))
            data = data_class(tempdir)
        except TypeError, exc:
            message(DEBUG, 'class complains: %s' % str(exc))
            continue
    if not data:
        raise DataError('unrecognized data format')
    message(DEBUG, 'class %s accepted the data' % str(data.__class__))

    if args.volume:
        for fname in args.volume:
            message(NOTICE, 'creating %s...' % fname)
            if fname.endswith('.nii.gz'):
                data.nii_gz(fname)

    if args.thumbnail:
        message(NOTICE, 'creating %s...' % args.thumbnail)
        data.check_call(['slicer', data.nii_gz(), '-a', args.thumbnail])

    if args.image03:
        if args.image03 == '-':
            fo = sys.stdout
        else:
            message(NOTICE, 'writing image03 to %s...' % args.image03)
            fo = open(args.image03, 'w')
        try:
            if args.format == 'text':
                max_width = max([ len(f) for f in image03_fields ])
                for field in image03_fields:
                    val = data.image03[field]
                    if val is None:
                        str_val = ''
                    else:
                        str_val = str(val)
                    fo.write('%s = %s\n' % (field.ljust(max_width), str_val))
            else:
                json.dump(data.image03, fo)
                fo.write('\n')
        finally:
            if fo is not sys.stdout:
                fo.close()

    if not args.volume and not args.thumbnail and not args.image03:
        message(NOTICE, 'data okay')

except Exception, exc:

    if isinstance(exc, DataError):
        ev = 3
    elif isinstance(exc, UndeterminedError):
        ev = 4
    else:
        ev = 1

    if args.debug_flag:
        message(DEBUG, traceback.format_exc(exc))
    else:
        message(ERROR, str(exc))

    sys.exit(ev)

except KeyboardInterrupt:

    message(ERROR, 'caught keyboard interrupt, exiting')
    sys.exit(1)

finally:

    if args.clean_flag:
        message(DEBUG, 'removing temporary directory %s' % tempdir)
        shutil.rmtree(tempdir)
    else:
        message(NOTICE, 'leaving temporary directory %s' % tempdir)

sys.exit(0)

# eof
